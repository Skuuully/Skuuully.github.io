<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-05-08T13:43:33+01:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Ryan Skull</title><subtitle>Ryan Skull Portfolio.</subtitle><author><name>Ryan Skull</name></author><entry><title type="html">CVRS: Covid visualisation</title><link href="http://localhost:4000/cvrs/" rel="alternate" type="text/html" title="CVRS: Covid visualisation" /><published>2021-05-08T11:10:00+01:00</published><updated>2021-05-08T11:10:00+01:00</updated><id>http://localhost:4000/covid-visualisation</id><content type="html" xml:base="http://localhost:4000/cvrs/">&lt;p&gt;For my independent studies dissertation I decided to look at creating a virtual reality application that depicts the transmission of COVID-19 in a university setting. The application allows for the transmission of COVID-19 between AI agents, and visualises this by using a border outline. The work builds upon that of a previous university student who created the base VR application which showcases social distancing between the agents. The project that I carried out then adds the transmission of a virus, a different view to perceive this within, a schedule system for the agents to follow, and a way to export the transmission that occurred for validation. The main idea behind building the project was to discover if presenting the data in this way is suitable, and if it could be used to help display the potential transmission to the general public.&lt;/p&gt;

&lt;h2&gt;Transmission&lt;/h2&gt;
&lt;p&gt;The following &lt;a href=&quot;https://arxiv.org/pdf/1907.08829.pdf&quot;&gt;paper&lt;/a&gt; served as the main inspiration for the way that transmission works within the application, the SIRI model is adapted changing an adjacency matrix for some parameters sampled at run time such as mask adoption, and distance. The equations derived for the compartmental models used are the following:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/_assets/images/cvrs/SIReq.png&quot; alt=&quot;SIReq&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The compartments used follow the basics set out, a susceptible, infected, and removed compartment exist. The agents change states between these state maintaining a percentage chance that they are in each state. The agents may begin with each state in any chance, however all states for a given agent sum to 100%. For the simulations run a class of agents would start with all agents susceptible except for one who would start wholly in the the infected state. Then the agents in the susceptible state would transition into the removed state based on their interaction with the infected agent, and then into the removed state based on the recovery parameter. Within the model there is the beta parameter used, this is what replaces the adjacency matrix mentioned earlier to get a value from this the data from two agents at a given point in time are used, the equation is as follows:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/_assets/images/cvrs/Infectivity-eq.png&quot; alt=&quot;Infectivity-eq&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The three parameters in the equation are:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;A base infectivity parameter, this can be modified to make the virus more or less contagious&lt;/li&gt;
    &lt;li&gt;A sampling of the distance between the two agents, the further away the agents are the less contagious on a quadratic scale, after a distance of 5m the virus is treated as having no effect&lt;/li&gt;
    &lt;li&gt;An adjacency matrix based on mask adoption between the two agents&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The combination of then allows the infection to be transmitted between agents, the outline then handles turning the infection chance into an outline of white to red where white is less infected and red more. This is then viewed from a top down perspective, with some UI that gives additional detail.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/_assets/images/cvrs/InfectionOutline.png&quot; alt=&quot;InfectionOutline&quot; /&gt;
&lt;img src=&quot;/_assets/images/cvrs/InGameUI.png&quot; alt=&quot;InGameUI&quot; /&gt;&lt;/p&gt;

&lt;p&gt;With all this in place the application shows the transmission of the virus between two agents. There are additionally schedules on top of this that then allows control of the agents in the scene. This allows for running of different scenarios, for example one scenario is created where 10 agents go to class for 2 hours then go home, all wear masks and a single agent begins as infected. Another identical scenario is created with the change that no agents wear masks. The simulation was then run and data exported into a JSON format then graphed in MATLAB to show the infection over time.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/_assets/images/cvrs/MaskComparison.png&quot; alt=&quot;Graph&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This helped to show that the simulation worked as expected, and that individual runs would produce the same results as can be seen by the similarity in when the infection changes between the two scenarios. There is more detail than has been divulged here, but this will be the stopping point for this post covering the transmission. The project was interesting to work on due to its mix of science, virtual reality, and computer science, and gave me a fair project to then write up about to produce a dissertation.&lt;/p&gt;</content><author><name>Ryan Skull</name></author><summary type="html">For my independent studies dissertation I decided to look at creating a virtual reality application that depicts the transmission of COVID-19 in a university setting. The application allows for the transmission of COVID-19 between AI agents, and visualises this by using a border outline. The work builds upon that of a previous university student who created the base VR application which showcases social distancing between the agents. The project that I carried out then adds the transmission of a virus, a different view to perceive this within, a schedule system for the agents to follow, and a way to export the transmission that occurred for validation. The main idea behind building the project was to discover if presenting the data in this way is suitable, and if it could be used to help display the potential transmission to the general public.</summary></entry><entry><title type="html">Gravity game</title><link href="http://localhost:4000/gravity/" rel="alternate" type="text/html" title="Gravity game" /><published>2021-05-08T11:08:00+01:00</published><updated>2021-05-08T11:08:00+01:00</updated><id>http://localhost:4000/gravity</id><content type="html" xml:base="http://localhost:4000/gravity/">&lt;p&gt;A university module required the creation of a game that looks at and implements an advanced physics topic, and an advanced AI topic. 
For this I created the &lt;a href=&quot;https://skuuully.itch.io/planet-game&quot;&gt;following&lt;/a&gt; available for download.
For the physics topic I looked at gravity such that an object being an attractee could be attracted to another object the attractor,
 allowing the attractees to be attracted to and move around an attractor. Then for the AI I wanted agents that could move around the surface
 of the attractor, this led me to discover flow field pathfinding. This led to the creation of a game where the player can move around
 small differently shaped planets shooting enemies that chase them, the game had an added element of uniqueness as players can shoot themselves
 when their bullets wrap back around the planet to hit them.&lt;/p&gt;

&lt;h2&gt;Physics: Gravity&lt;/h2&gt;
&lt;p&gt;The functionality is split out into two main parts, attractors and attractees. By doing so this allows control over which objects are attracted to the planets, and which objects serve as the planets. Attractees work using Unity’s rigidbody – however the rotation is frozen giving control of the rotation, and gravity disabled, allowing for a custom gravity implementation. The behaviour of an attractee is to find the attractors face that the attractee is nearest; this is done by ray casts. Once an attractor is found, use the surface normal from the ray cast to orient the object so that its up is in line with the surface normal. First a ray is cast downwards from the attractee, in most cases this will find the attractor, and for a spherical planet is the only method required. However, for cube shaped planets this alone will not work as walking off the edge of a body will not find the surface. In this scenario a cone of rays is cast below the player.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/_assets/images/gravity/WalkDemo.gif&quot; alt=&quot;WalkDemo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Also implemented are projectiles that can be shot by the player. A projectile is an attractee, combining this with a constant forward force allows the projectile to move forwards. As it moves around a surface its forwards will change allowing it to wrap around a sphere. Most basic unity meshes have been tested that would make sense as a play space, such as sphere, cube, capsule, and cylinder. All allow the projectiles to move around them in a believable way.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/_assets/images/gravity/SelfShooting.gif&quot; alt=&quot;Selfshoot&quot; /&gt;&lt;/p&gt;
&lt;p&gt;For this, assumptions are made that there is no air resistance, or changes in air pressure. The level of gravity also remains the same regardless of the distance from the surface, or centre of mass for the attractor. Additionally, all objects are assumed to be rigid. These assumptions are made, as including them would add extra complexity which is unnecessary for the game feel. As the attractor to use is always decided by looking below the attractee then we cannot transition from the sphere to the cube. The angle is too large between the two to be recognised. Another limitation is that models used as attractors must be fairly high poly for attractees to smoothly follow the shape of the object. Otherwise a low poly sphere for example may not feel very sphere like to move around.&lt;/p&gt;

&lt;h2&gt;AI: Flow field pathfinding&lt;/h2&gt;
&lt;p&gt;Flow-field pathfinding is used to allow pathfinding on the exterior of 3d objects. One of the main difficulties to implementing this is generating the nodes and connections to apply the pathfinding to. To generate the nodes the mesh data of the object is used. Foreach triangle in the mesh a node is created which is connected to the other nodes in the triangle. Only the shortest of the two connections are connected to avoid diagonal connections, diagonals can cause issues when obstacles are present. Once converted there will be multiple nodes with the same position where the triangles meet. So, merge nodes with the same position into one node containing all connections of the nodes in the same position. This can generate a grid to find a path on.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/_assets/images/gravity/SphereGrid.png&quot; alt=&quot;SphereGrid&quot; /&gt;&lt;/p&gt;

&lt;p&gt;As mesh data is used, this can present issues with there being too few nodes. To counter this the mesh may be subdivided multiple times first, decreasing the size of the mesh triangles but increasing the number of nodes in the grid making it more accurate. A comparison of a cube subdivided 0 times against 3 times can be seen below. To subdivide the mesh an external &lt;a href=&quot;https://wiki.unity3d.com/index.php/MeshHelper&quot;&gt;source&lt;/a&gt; has been used.
&lt;img src=&quot;/_assets/images/gravity/SubdivComparison.png&quot; alt=&quot;Subdiv&quot; /&gt;&lt;/p&gt;

&lt;p&gt;With the grid generated the flow-field technique can be applied. The main code that does this can be seen below. Within to represent a collision a nodes cost is set to 255, so to generate we skip evaluating the connection if the connected has a cost of 255. Additionally, the target nodes direction is set to point directly to the target position given. This allows agents to get to the target position not just the target node.&lt;/p&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Code that generates the flow field&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;SetAllUnreachable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;targetNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;SetValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;targetNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;SetDirection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;targetPosition&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;targetNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;currentNode&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;targetNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;open&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;currentNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Count&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;currentNode&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Remove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;currentNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;foreach&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;connectedNodeID&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;currentNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;connectedNodes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;connectedNode&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_nodes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;connectedNodeID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;connectedNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Active&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pathLength&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;currentNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;connectedNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cost&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pathLength&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;connectedNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Contains&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;connectedNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;connectedNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

                &lt;span class=&quot;n&quot;&gt;connectedNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;SetValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pathLength&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;currentNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;To make an agent that follows the field, a forward force is given, then when moving update the rotation to look in the direction of the flow-field. The agent uses this rotation to slowly rotate towards, causing it to follow the field smoothly without instantly snapping to the new direction. To resolve issues on the very edge of the cube the agent will ignore the flow-fields direction if it will cause the agent to look at the walkable surface. Only after it gets over the edge will it then use its direction. An example flow-field with a player as the target point and an agent trying to get to the player with a collision can be seen below. The Lines between the nodes show the nodes direction vector, a greener line also helps visualise its closeness to the target.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/_assets/images/gravity/FlowField.png&quot; alt=&quot;FlowField&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;Thanks for reading&lt;/h2&gt;
&lt;p&gt;Reminder that the game can be downloaded &lt;a href=&quot;https://skuuully.itch.io/planet-game&quot;&gt;here&lt;/a&gt; to play&lt;/p&gt;</content><author><name>Ryan Skull</name></author><summary type="html">A university module required the creation of a game that looks at and implements an advanced physics topic, and an advanced AI topic. For this I created the following available for download. For the physics topic I looked at gravity such that an object being an attractee could be attracted to another object the attractor, allowing the attractees to be attracted to and move around an attractor. Then for the AI I wanted agents that could move around the surface of the attractor, this led me to discover flow field pathfinding. This led to the creation of a game where the player can move around small differently shaped planets shooting enemies that chase them, the game had an added element of uniqueness as players can shoot themselves when their bullets wrap back around the planet to hit them.</summary></entry></feed>